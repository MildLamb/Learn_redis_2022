# Redis基本数据类型
## String 字符串
### 简介
- String类型是二进制安全的。意味着Redis的string可以包含任何数据，比如图片或者序列化的对象。
- String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M

### 基本命令
- set <key> <value> : 添加键值对
  - *NX : 当前数据库中key不存在时，可以将key-value添加数据库
  - *XX ：当数据库中key存在时，可以将key-value添加数据库，与NX互斥
  - *EX ：key的超时时间
  - *PX ：key的超时毫秒数，与EX互斥
  
- get <key> : 获取对应key的值
- append <key> <value> : 追加value值
- strlen <key> : 获取值的长度
- setnx <key> <value> : key不存在时才可以设置该键值对
- incr <key> : 将key中存储的数字值增1，只能对数字值操作，如果为空，新增值为1，想增加几使用 incrby
- decr <key> : 将key中存储的数字值减1，只能对数字值操作，如果为空，新减值为-1，想减少几使用 decrby
- mset <key1> <value1> <key2> <value2> ... : 同时设置一个或多个key-value对
- mget <key1> <key2> <key3> ... : 同时获取一个或多个value
- msetnx <key1> <value1> <key2> <value2> ... : 同时设置多个键值对，当且仅当所给定的key都不存在
- getrange <key> <开始索引> <结束索引> ：截取value的值
- setrange <key> <开始索引> <value> : 更改指定位置开始的内容
- setex <key> <seconds> <value> : 创建键值对并设置过期时间
- getset <key> <value> ：获取旧值的同时设置新值
  
  
```bash
127.0.0.1:6379> set name mildlamb
OK
127.0.0.1:6379> set name2 wildwolf
OK
127.0.0.1:6379> keys *
1) "name2"
2) "name"
127.0.0.1:6379> append name "and wildwolf"
(integer) 20
127.0.0.1:6379> get name
"mildlamband wildwolf"
127.0.0.1:6379> strlen name
(integer) 20
127.0.0.1:6379> setnx name mildlamb
(integer) 0
127.0.0.1:6379> get name
"mildlamband wildwolf"
127.0.0.1:6379> set num 5
OK
127.0.0.1:6379> incr num
(integer) 6
127.0.0.1:6379> incrby num 4
(integer) 10
127.0.0.1:6379> decr num
(integer) 9
127.0.0.1:6379> decrby num 4
(integer) 5
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> mset name1 mildlamb name2 gnar name3 neeko
OK
127.0.0.1:6379> keys *
1) "name3"
2) "name2"
3) "name1"
127.0.0.1:6379> mget name1 name2 name3
1) "mildlamb"
2) "gnar"
3) "neeko"
127.0.0.1:6379> getrange name1 0 3
"mild"
127.0.0.1:6379> setrange name1 4 kind
(integer) 8
127.0.0.1:6379> get name1
"mildkind"
127.0.0.1:6379> setex test 20 qsj
OK
127.0.0.1:6379> ttl test
(integer) 8
127.0.0.1:6379> ttl test
(integer) -2
127.0.0.1:6379> getset name1 mildlamb
"mildkind"
```
  
  
  
  
  
  
  
  
  
# 扩展问题 两个线程分别对int i=0进行i++一百次
极端情况测试输出为2  

第一步：  
线程A执行第一次a++，取出内存中的a，值为0，存放到寄存器后执行加1，此时CPU1的寄存器中值为1，内存中为0；  
线程B执行第一次a++，取出内存中的a，值为0，存放到寄存器后执行加1，此时CPU2的寄存器中值为1，内存中为0；  

第二步：  
线程A继续执行完成第99次a++，并把值放回内存，此时CPU1中寄存器的值为99，内存中为99；  

第三步：  
线程B继续执行第一次a++，将其值放回内存，此时CPU2中的寄存器值为1，内存中为1；  

第四步：  
线程A执行第100次a++，将内存中的值取回CPU1的寄存器，并执行加1，此时CPU1的寄存器中的值为2，内存中为1；  

第五步：  
线程B执行完剩下的99次操作，并将其放回内存，此时CPU2的寄存器值为100，内存中为100；  

第六步：  
线程A执行100次操作的最后一部分，将CPU1中的寄存器值2放回内存，将原本的100覆盖,内存中值为2；  

  
<hr>
  
## Redis列表(List)
### 简介
- 单键多值
- Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头(左部)或者尾(右部)
- 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标操作中间的节点性能会较差
  
### 常用命令
- lpush/rpush <key> <value1> <value2> ... : 从左边/右边插入一个或多个值
- lpop/rpop <key> : 从左边/右边吐出一个值。值在键在，值光键亡。
- rpoplpush <key1> <key2> : 从key1列表右边吐出一个值，插入到key2列表左边
- lrange <key> <start> <stop> : 按照索引下标获取元素(从左到右)
- lindex <key> <index> : 按照索引下标获取元素(从左到右)
- llen <key> : 获取列表长度
- linsert <key> <before/after> <value> <newvalue> : 在指定列表的某个值前面/后面插入新值，取决于你是lpush还是rpush
- lrem <key> <n> <value> : 从左边删除n个value
- lset <key> <index> <newvalue> : 将key列表下标为index的值替换为newvalue
  
```bash
127.0.0.1:6379> lpush roles kindred gnar neeko
(integer) 3
127.0.0.1:6379> lrange roles 0 -1
1) "neeko"
2) "gnar"
3) "kindred"
127.0.0.1:6379> rpush roles2 kindred gnar neeko
(integer) 3
127.0.0.1:6379> lrange roles2 0 -1
1) "kindred"
2) "gnar"
3) "neeko"
127.0.0.1:6379> lpop roles
"neeko"
127.0.0.1:6379> lpop roles2
"kindred"
127.0.0.1:6379> rpop roles
"kindred"
127.0.0.1:6379> rpop roles2
"neeko"
127.0.0.1:6379> rpoplpush roles2 roles
"gnar"
127.0.0.1:6379> keys *
1) "roles"
127.0.0.1:6379> lrange roles 0 -1
1) "gnar"
2) "gnar"
127.0.0.1:6379> lpush roles2 kindred gnar neeko
(integer) 3
127.0.0.1:6379> lindex roles2 1
"gnar"
127.0.0.1:6379> llen roles2
(integer) 3
127.0.0.1:6379> linsert roles2 after gnar QSJ
(integer) 4
127.0.0.1:6379> lrange roles2 0 -1
1) "neeko"
2) "gnar"
3) "QSJ"
4) "kindred"
127.0.0.1:6379> lset roles2 2 qsj
OK
127.0.0.1:6379> lrange roles2 0 -1
1) "neeko"
2) "gnar"
3) "qsj"
4) "kindred"
```
  
### 数据结构
- List的数据结构为快速链表 quickList
- 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也就是压缩列表
- 它将所有的元素紧挨着一起存储，分配的是一块连续的内存
- 当数据量比较多的时候才会改成 quicklist
- Redis将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist使用双向指针串起来，这样既满足了快速的插入删除性能，又不会出现太大的空间冗余
  
![image](https://user-images.githubusercontent.com/92672384/179136111-bf5f97e4-09d9-4370-923b-a540641d981f.png)
