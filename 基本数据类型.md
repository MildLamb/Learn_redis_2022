# Redis基本数据类型
## String 字符串
### 简介
- String类型是二进制安全的。意味着Redis的string可以包含任何数据，比如图片或者序列化的对象。
- String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M

### 基本命令
- set <key> <value> : 添加键值对
  - *NX : 当前数据库中key不存在时，可以将key-value添加数据库
  - *XX ：当数据库中key存在时，可以将key-value添加数据库，与NX互斥
  - *EX ：key的超时时间
  - *PX ：key的超时毫秒数，与EX互斥
  
- get <key> : 获取对应key的值
- append <key> <value> : 追加value值
- strlen <key> : 获取值的长度
- setnx <key> <value> : key不存在时才可以设置该键值对
- incr <key> : 将key中存储的数字值增1，只能对数字值操作，如果为空，新增值为1，想增加几使用 incrby
- decr <key> : 将key中存储的数字值减1，只能对数字值操作，如果为空，新减值为-1，想减少几使用 decrby
- mset <key1> <value1> <key2> <value2> ... : 同时设置一个或多个key-value对
- mget <key1> <key2> <key3> ... : 同时获取一个或多个value
- msetnx <key1> <value1> <key2> <value2> ... : 同时设置多个键值对，当且仅当所给定的key都不存在
- getrange <key> <开始索引> <结束索引> ：截取value的值
- setrange <key> <开始索引> <value> : 更改指定位置开始的内容
- setex <key> <seconds> <value> : 创建键值对并设置过期时间
- getset <key> <value> ：获取旧值的同时设置新值
  
  
```bash
127.0.0.1:6379> set name mildlamb
OK
127.0.0.1:6379> set name2 wildwolf
OK
127.0.0.1:6379> keys *
1) "name2"
2) "name"
127.0.0.1:6379> append name "and wildwolf"
(integer) 20
127.0.0.1:6379> get name
"mildlamband wildwolf"
127.0.0.1:6379> strlen name
(integer) 20
127.0.0.1:6379> setnx name mildlamb
(integer) 0
127.0.0.1:6379> get name
"mildlamband wildwolf"
127.0.0.1:6379> set num 5
OK
127.0.0.1:6379> incr num
(integer) 6
127.0.0.1:6379> incrby num 4
(integer) 10
127.0.0.1:6379> decr num
(integer) 9
127.0.0.1:6379> decrby num 4
(integer) 5
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> mset name1 mildlamb name2 gnar name3 neeko
OK
127.0.0.1:6379> keys *
1) "name3"
2) "name2"
3) "name1"
127.0.0.1:6379> mget name1 name2 name3
1) "mildlamb"
2) "gnar"
3) "neeko"
127.0.0.1:6379> getrange name1 0 3
"mild"
127.0.0.1:6379> setrange name1 4 kind
(integer) 8
127.0.0.1:6379> get name1
"mildkind"
127.0.0.1:6379> setex test 20 qsj
OK
127.0.0.1:6379> ttl test
(integer) 8
127.0.0.1:6379> ttl test
(integer) -2
127.0.0.1:6379> getset name1 mildlamb
"mildkind"
```
  
  
  
  
  
  
  
  
  
# 扩展问题 两个线程分别对int i=0进行i++一百次
极端情况测试输出为2  

第一步：  
线程A执行第一次a++，取出内存中的a，值为0，存放到寄存器后执行加1，此时CPU1的寄存器中值为1，内存中为0；  
线程B执行第一次a++，取出内存中的a，值为0，存放到寄存器后执行加1，此时CPU2的寄存器中值为1，内存中为0；  

第二步：  
线程A继续执行完成第99次a++，并把值放回内存，此时CPU1中寄存器的值为99，内存中为99；  

第三步：  
线程B继续执行第一次a++，将其值放回内存，此时CPU2中的寄存器值为1，内存中为1；  

第四步：  
线程A执行第100次a++，将内存中的值取回CPU1的寄存器，并执行加1，此时CPU1的寄存器中的值为2，内存中为1；  

第五步：  
线程B执行完剩下的99次操作，并将其放回内存，此时CPU2的寄存器值为100，内存中为100；  

第六步：  
线程A执行100次操作的最后一部分，将CPU1中的寄存器值2放回内存，将原本的100覆盖,内存中值为2；  
